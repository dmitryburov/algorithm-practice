# A. Packed Prefix

Вам даны строки в запакованном виде. Определим запакованную строку (ЗС) рекурсивно. Строка, состоящая только из строчных букв английского алфавита является ЗС. Если A и B —– корректные ЗС, то и AB является ЗС. Если A —– ЗС, а n — однозначное натуральное число, то n[A] тоже ЗС. При этом запись n[A] означает, что при распаковке строка A записывается подряд n раз. Найдите наибольший общий префикс распакованных строк и выведите его (в распакованном виде).

Иными словами, пусть сложение —– это конкатенация двух строк, а умножение строки на число — повтор строки соответствующее число раз. Пусть функция f умеет принимать ЗС и распаковывать её. Если ЗС D имеет вид D=AB, где A и B тоже ЗС, то f(D) = f(A) + f(B). Если D=n[A], то f(D) = f(A) × n.

## Формат ввода

В первой строке записано число n (1 ≤ n ≤ 1000) –— число строк.

Далее в n строках записаны запакованные строки. Гарантируется, что эти строки корректны, то есть удовлетворяют указанному рекурсивному определению. 
Длина строк после распаковки не превосходит 10<sup>5</sup>.

## Формат вывода

Выведите наибольший общий префикс распакованных строк.

### Пример 1

<table><tr>
<td>
3<br>
2[a]2[ab]<br>
3[a]2[r2[t]]<br>
a2[aa3[b]]
</td>
<td>
aaa<br>
<br>
<br>
<br>
</td>
</tr></table>

### Пример 2

<table><tr>
<td>
3<br>
abacabaca<br>
2[abac]a<br>
3[aba]
</td>
<td>
aba<br>
<br>
<br>
<br>
</td>
</tr></table>


### Примечания

Сложение подразумевается как конкатенация двух строк. Умножение строки на число — повтор строки соответствующее число раз. Пусть функция f умеет принимать ЗС и распаковывать ее. Если ЗС D имеет вид D=AB, где A и B тоже ЗС, то f(D) = f(A) + f(B). Если , то f(D) = f(A) × n.




